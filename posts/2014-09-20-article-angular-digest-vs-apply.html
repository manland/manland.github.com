<!DOCTYPE html><html lang="fr-fr"><head><meta charset="utf-8"><title>Romain Maneschi - $scope.$disgest vs $scope.$apply</title><meta name="author" content="Romain Maneschi"><meta name="viewport" content="width=device-width"><link href="http://fonts.googleapis.com/css?family=Open+Sans" rel="stylesheet" type="text/css"><link rel="stylesheet" type="text/css" href="/assets/css/default-20150317.css"><link rel="stylesheet" type="text/css" href="/assets/css/monokai_sublime-20150317.css"><link rel="alternate" type="application/rss+xml" title="RSS" href="/feed.xml"><link rel="shortcut icon" type="image/ico" href="/assets/images/favicon.ico"><script type="text/javascript">var _gaq = _gaq || [];
      _gaq.push(['_setAccount', 'UA-36759922-1']);
      _gaq.push(['_trackPageview']);

      (function() {
        var ga = document.createElement('script'); ga.type = 'text/javascript'; ga.async = true;
        ga.src = ('https:' == document.location.protocol ? 'https://ssl' : 'http://www') + '.google-analytics.com/ga.js';
        var s = document.getElementsByTagName('script')[0]; s.parentNode.insertBefore(ga, s);
      })();</script></head><body><header><a class="title" href="/index.html"><img class="presentation-img" src="/assets/images/romain.png"><div class="presentation-name"><span>Romain Maneschi</span> <span class="presentation-baseline">Artisan développeur</span></div></a><nav><a href="/index.html" class="btn">Accueil</a> <a href="/cv.html" class="btn btn-cv"> CV</a> <a href="/projets.html" class="btn btn-projet"> Projets</a> <a href="/articles.html" class="btn btn-article"> Ecrits</a> <a href="/contact.html" class="btn social-network-tab">Contact</a></nav><div class="social-network"><a href="/assets/images/CV_Romain_Maneschi.pdf" target="_blank"><img src="/assets/images/cvpdf.gif" width="30px"></a> <a href="https://twitter.com/RmManeschi" target="_blank"><img src="/assets/images/brand/twitter.png" width="30px"></a> <a href="https://github.com/manland" target="_blank"><img src="/assets/images/brand/github.png" width="30px"></a> <a href="http://www.viadeo.com/fr/profile/romain.maneschi" target="_blank"><img src="/assets/images/brand/viadeo.png" width="30px"></a> <a href="http://www.linkedin.com/pub/romain-maneschi/5b/422/aa9" target="_blank"><img src="/assets/images/brand/linkedin.png" width="30px"></a> <a href="https://plus.google.com/+RomainManeschi" target="_blank"><img src="/assets/images/brand/googleplus.png" width="30px"></a> <a href="/feed.xml" target="_blank"><img src="/assets/images/brand/rss.png" width="30px"></a></div></header><div class="container-max"><div class="article-max"><span class="publish-date">Sep 2014</span><h2 class="article-title">$scope.$disgest vs $scope.$apply</h2><div class="container-img"><img id="image" src="/assets/images/presentation/angularjs-logo.png" alt="$scope.$disgest vs $scope.$apply screenshot" onclick="GALLERY.showBig()"></div><div id="urls" style="display:none">presentation/angularjs-logo.png</div><script type="text/javascript" src="/assets/js/gallery-20150317.js"></script><p>Lorsqu&#39;on veut aller plus loin avec <a href="https://angularjs.org/" class="link-pink">AngularJs</a>, on doit comprendre les mécanismes internes de ce framework. L&#39;un des plus important est la façon dont il gère le rafraîchissement de la vue par rapport au modèle et le contraire.</p><p>A première vue, AngularJs paraît complexe, mais en réalité il est très simple de comprendre comment il fait pour maintenir à jour la vue et le modèle. A chaque fois que vous faites un &#123;{ data }} dans le dom AngularJs fait un $scope.$watch(&#39;data&#39;, functionCallback). C&#39;est tout simplement un écouteur sur la propriété data du $scope. Donc lorsqu&#39;il y aura une modification de $scope.data AngularJs appellera functionCallback qui mettra à jour le dom html avec la nouvelle valeur.</p><p>La question suivante est donc, quand et comment AngularJs va détecter une modification de $scope.data ?</p><p>Imaginons un premier cas simple où l&#39;on va mettre à jour cette donnée après 1 seconde grâce à la fonction setTimeout de javascript :</p><div class="code"><div class="code-filename">myCtrl.js</div><pre><code class="language-javascript">angular.module(<span class="hljs-string">'app'</span>).controller(<span class="hljs-string">'myCtrl'</span>, [
    <span class="hljs-string">'$scope'</span>,
    <span class="hljs-function"><span class="hljs-keyword">function</span><span class="hljs-params">($scope)</span> </span>{
        $scope.data = <span class="hljs-number">1</span>;
        setTimeout(<span class="hljs-function"><span class="hljs-keyword">function</span><span class="hljs-params">()</span> </span>{
            $scope.data = <span class="hljs-number">2</span>;
        }, <span class="hljs-number">1000</span>);
    }
]);</code></pre><p></p></div><p>Si vous exécutez ce code il ne se passera rien. En effet, $scope.data = 2 est en dehors d&#39;AngularJs il ne saura donc pas que le $scope a changé et ne mettra pas à jour la vue. Après une petite recherche sur le net on nous apprend qu&#39;il faut un $scope.$apply() après avoir mis à jour $scope.data pour qu&#39;AngularJs lance une phase de digestion.</p><div class="code"><div class="code-filename">myCtrl.js</div><pre><code class="language-javascript">angular.module(<span class="hljs-string">'app'</span>).controller(<span class="hljs-string">'myCtrl'</span>, [
    <span class="hljs-string">'$scope'</span>,
    <span class="hljs-function"><span class="hljs-keyword">function</span><span class="hljs-params">($scope)</span> </span>{
        $scope.data = <span class="hljs-number">1</span>;
        setTimeout(<span class="hljs-function"><span class="hljs-keyword">function</span><span class="hljs-params">()</span> </span>{
            $scope.data = <span class="hljs-number">2</span>;
            $scope.$apply();
        }, <span class="hljs-number">1000</span>);
    }
]);</code></pre><p></p></div><p>Mais qu&#39;est-ce qu&#39;une phase de digestion ? C&#39;est tout simplement une visite de tous les scopes de l&#39;application, si il y a une modification sur une propriété du $scope on appelle les functionCallback des $watch (rappelez vous on en a parlé juste au dessus). On peut simplifier le code du scope comme ça :</p><div class="code"><div class="code-filename">same-as-scope.js</div><pre><code class="language-javascript"><span class="hljs-keyword">var</span> watchers = [<span class="hljs-comment">/*{data: [callbakcs]}*/</span>];

$scope.watch = <span class="hljs-function"><span class="hljs-keyword">function</span><span class="hljs-params">(data, callback)</span> </span>{
    watchers[data] = watchers[data] || [];
    watchers[data].push(callback);
};

$scope.visit = <span class="hljs-function"><span class="hljs-keyword">function</span><span class="hljs-params">()</span> </span>{
    <span class="hljs-keyword">for</span>(<span class="hljs-keyword">var</span> data <span class="hljs-keyword">in</span> watchers) {
        <span class="hljs-keyword">if</span>(isModified(data)) {
            watchers.forEach(<span class="hljs-function"><span class="hljs-keyword">function</span><span class="hljs-params">(callback)</span> </span>{
                callback();
            });
        }
    }
    childrenScope.forEach(<span class="hljs-function"><span class="hljs-keyword">function</span><span class="hljs-params">(childScope)</span> </span>{
        childScope.visit();
    });
}</code></pre><p></p></div><p>Heu, je pige pas pourquoi on fait un $scope.$apply() alors qu&#39;on pourrait faire un $scope.$digest(), surtout que ce dernier ressemble furieusement à la digestion !?</p><p>On comprend très rapidement en allant voir l&#39;implémentation de $scope.$apply(), il pourrait être simplifié en :</p><div class="code"><div class="code-filename">same-as-rootscope.js</div><pre><code class="language-javascript">$rootScope.$digest = <span class="hljs-function"><span class="hljs-keyword">function</span><span class="hljs-params">()</span> </span>{
    childrenScope.forEach(<span class="hljs-function"><span class="hljs-keyword">function</span><span class="hljs-params">(childScope)</span> </span>{
        childScope.visit();
    });
}

$scope.$apply = <span class="hljs-function"><span class="hljs-keyword">function</span><span class="hljs-params">()</span> </span>{
    $rootScope.$digest();    
};</code></pre><p></p></div><p>Donc lorsqu&#39;on appelle $scope.$apply() en réalité on lance une phase de digestion sur le $rootScope, qui est le père de tous les scopes, et va donc visiter tous les scopes de votre application.</p><p>Petite rectification, depuis le début je vous dis qu&#39;on visite les scopes (pour suivre le pattern visitor bien évidemment), en réalité on ne visite pas un scope on le digère. En effet, la fonction visit est la fonction $digest.</p><p>Mais alors doit-on appeler $scope.$apply() ou $scope.digest() ? Si on suit les recommandations d&#39;AngularJs il faut uniquement appeler $scope.$apply(), en effet si une modification de $scope génère une modification d&#39;un autre $scope plus haut dans la hiérarchie de scopes et donc du dom html, nos modifications ne seront pas répercutées.</p><p>Par contre si vous savez exactement ce que vous faites un $scope.$digest() sera forcément plus performant qu&#39;un $scope.$apply(). Mais n&#39;oubliez pas que c&#39;est de l&#39;ordre de la micro-optimisation.</p><h2 id="exemple-concret">Exemple concret</h2><p>Je ne sais pas pour vous mais moi j&#39;aime bien valider ce qu&#39;on m&#39;explique. Pour réaliser cet article j&#39;ai donc créé deux petites applications AngularJs. La première va émettre un $scope.$digest() lors d&#39;une modification. La deuxième un $scope.$apply(). Testez par vous même en créant des scopes et en modifiant la donnée (qui n&#39;est rien d&#39;autre qu&#39;un compteur s&#39;incrémentant).</p><iframe width="100%" height="300" src="http://jsfiddle.net/manland/agnnrdL8/embedded/result" allowfullscreen="allowfullscreen" frameborder="0"></iframe><p>La même application mais avec $scope.apply() au lieu de $scope.$digest().</p><iframe width="100%" height="300" src="http://jsfiddle.net/manland/98g6bx6s/embedded/result" allowfullscreen="allowfullscreen" frameborder="0"></iframe><p>N&#39;hésitez pas à aller voir le code, à le modifier et à jouer avec tout ça !</p><h2 id="pour-aller-plus-loin">Pour aller plus loin</h2><p>Dans AngularJs qu&#39;est ce qui appelle $apply pour nous ?</p><p>On ne va pas se le cacher, la grande force d&#39;AngularJs est sa magie qui fait instantanément refléter l&#39;update de notre modèle sur notre vue et vice versa. Mais comme nous venons de le voir cette magie est en réalité un simple visitor pattern câblé avec un observer/observator pattern.</p><p>Pour que la magie opère, AngularJs réalise un $rootScope.$digest() à notre place dans les composants suivant :</p><ul><li>$scope lorsqu&#39;on appelle $apply comme nous venons de le voir.</li><li>$browser lorsque l&#39;événement routeChange est émis.</li><li>$http lorsqu&#39;une requête est finie.</li><li>$interval / $timeout après avoir appelé la fonction de callback.</li><li>ngClick donc lorsque l&#39;utilisateur clique sur un élément html, AngularJs appelle la fonction de callback et fait une digestion globale.</li><li>textInput /radioButton / checkBox / ngOption... en gros la plupart des directives fournies par AngularJs</li></ul><p>Comme vous l&#39;avez compris, il n&#39;y a quasiment jamais besoin d&#39;appeler explicitement $digest() ou $apply(), mais dans les rares cas où c&#39;est nécessaire, je ne saurais que trop vous conseiller d&#39;utiliser $scope.$evalAsync(). Cette fonction qui ne fait rien d&#39;autre que d&#39;attendre la fin de la digestion courante (s&#39;il y en a une), et lancer un $rootScope.$digest().</p></div></div></body></html>